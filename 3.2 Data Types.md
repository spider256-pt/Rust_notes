- Every value in `"Rust"` is of a certain data type.
- Which tells Rust what kind of data is being specified.
- Rust is a statically typed language.
	- That means it must know the types of all variables at compile time.
## Types of Data Type:

- ### Scalar Types:
	
	- A scalar type represents a single value.
	- Rust has 4 primary scalar types:
		- `Integers`
		- `Floating-point`
		- `Booleans`
		- `Characters`
			
			- ### Integer Type:
				
				- A integer is a number without a fractional component. 
				- The type declaration indicates that the value its associated with should be an unsigned integer.
					- The signed integer types start with `i`, example: `i32`
					- The unsigned integer types start with `u`, example: `u32`
					- The number literal that can be multiple literal types allow a type suffix to designate the type.
					- The number literal can also use `_` as a visual separator. 
						- Example:
							- $$fn main(){
									let x :u32= "43".parse().expect("Not a number")
							} 
							$$
				- ##### Integer Overflow:
					
					- 
					
			- ### Floating-point Type:
				
				- Rust also has two primitive types for floating-point numbers
				- Rust floating types are `f32` and `f64` which are 32 bits and 64 bits in size.
				- The default type is f64 which is supports by modern computer CPU's.
				- All floating-points are signed.
					- Example:
						- $$ 
								fn main(){
									let x = 2.0; // f64
									let y: f32 = 2.0; //f32
							}
						 $$
			
			- ### Numeric Operations:
				
				- Rust supports the basic mathematical operations.
				- It do supports all the Arithmetic Operation.
				
				 - ![[Screenshot 2025-11-09 005615.png]]
			
			- ### The Boolean Type:
				
				-  In Rust the Boolean type has only two possible values
					- `true` 
					- `false`
				- The Boolean is specified by using `bool`
				- Example:
					- $$
							fn main(){
							let t = true;
							let f: bool = false;
					}
					$$
				- This is will only come in use by working with control statements.
			
			- ### The Character Type:
				
				- Rust's `char` type is the language's most primitive alphabetic type.
					- Example:
						- $$
							fn main(){
							let c = 'z';
							let z: char = 'Z'
							let heart_eyed_cat = 'ðŸ˜»';
						}
						$$

- ## Compound Type:
	
	-  Compound types can group multiple values into one type.
	- Rust has 2 compound type:
		- Tuples 
		- Arrays
			
			- ### The Tuple Type:
				
				-  A tuple is a general way of grouping a number of values with a variety of types into one compound type.
				- Tuples do have fixed length, once declared then cannot grow or shrink in size.
				- Example:
					- $$
						fn main(){
						let tup: (i32, f64, u8) = (500, 6.4, 1);
						
					}
					$$
				- To get the individual value out of tuple, use pattern matching to destructure a tuple value.
					- Example:
						- $$ fn main(){
								let tup: (i32, f64, u8)= (550,8.9,8);
								let (x, y, z) = tup;
								println!("The value of y i: {y}");
							}$$
				- Can also access a tuple element directly by using period `(.)` followed by the index of the value.
					- Example:
						- $$ fn main(){
									let tup: (i32, f64, u8) = (550, 9.4, 7);
									let five_fifty = tup.0;
									let nine_point_four = tup.1;
									let seven=tup.2;
								 }
							$$
			
			- ### The Array Type:
				
				- The Array type is a an another way to have a collection of multiple values.
				- Unlike ==`tuple`==, every element of an array must have  the same type.
				- Unlike arrays in some other languages, arrays in Rust have a fixed size.
				- Example:
					- $$
						fn main(){
							let x = [1,2,3,4,5];
						 }
					 $$
				- Arrays are useful when the data needs to be allocated on the stack.
				- An array type using square brackets with the type of each element, a semicolon, and then the number of elements in the array.
					- Example:
						- $$
							fn main(){
								let a:[i32;5] = [1,2,3,4,5];
							}
						$$
					- In this example the array a of type `i32` is having `5` `elements` and they are: `[1,2,3,4,5]`
				
				- We can also initialize an array to contain the same value for each element by specifying the initial value and the number if element that we need to exist inside the array.
					- Example:
						- $$
								fn main(){
									let a = [3;5]; 
								}
							$$
					- `output`:
						- `[3,3,3,3,3]`
				
				- ##### Accessing Array Elements:
					
					-  An array is a single chunk of memory of a known, fixed size that can be allocated on the stack.
					- We can access elements of an array using indexing:
						- $$
								fn main(){
									let a = [1,2,3,4,5];
									
									let first = a[0];
									let second = a[1];
								}
						$$
					
					
[[3.1 Variables and Mutability]]